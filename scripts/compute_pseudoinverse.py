"""
compute_pseudoinverse.py

Compute the Moore–Penrose pseudoinverse L^+ of the DLSFH Laplacian L,
save it as L_pinv.npy, and (optionally) compute the effective-resistance
matrix R_ij.

This script assumes L_dlsfh.npy has been generated by build_DLSFH.py.
If not found, it will call the constructor automatically.
"""

import os
from typing import Tuple

import numpy as np
from scipy.linalg import pinvh

from utils import (
    load_matrix,
    save_matrix,
    effective_resistance_matrix,
    print_spectrum_report,
    timed,
)
from build_DLSFH import build_and_save_L_dlsfh


# ---------------------------------------------------------------------------
# Core pseudoinverse computation
# ---------------------------------------------------------------------------

@timed
def compute_L_pinv(L: np.ndarray, rcond: float = 1e-12) -> np.ndarray:
    """
    Compute the Moore–Penrose pseudoinverse of a symmetric Laplacian.

    Parameters
    ----------
    L : np.ndarray
        Symmetric Laplacian matrix (n×n), rank n-1 for a connected graph.
    rcond : float, optional
        Cutoff for small eigenvalues used by pinvh.

    Returns
    -------
    np.ndarray
        Pseudoinverse L^+ of the same shape as L.
    """
    # pinvh is stable for symmetric positive semidefinite matrices.
    # We shift slightly in the null direction via rcond handling.
    L_pinv = pinvh(L, cond=1.0 / rcond, lower=True)
    return L_pinv


@timed
def main_compute(save_resistance: bool = True) -> Tuple[np.ndarray, np.ndarray]:
    """
    Main driver:
    - Load or build the DLSFH Laplacian L.
    - Compute L^+.
    - Optionally compute the effective-resistance matrix R.
    - Save all outputs under data/.

    Parameters
    ----------
    save_resistance : bool, optional
        If True, compute and save the effective-resistance matrix R_ij.

    Returns
    -------
    (np.ndarray, np.ndarray)
        (L_pinv, R) where R may be None if save_resistance is False.
    """
    # Try to load L; if missing, build it.
    try:
        L = load_matrix("L_dlsfh.npy")
        print("Loaded existing L_dlsfh.npy")
    except FileNotFoundError:
        print("L_dlsfh.npy not found; constructing DLSFH Laplacian...")
        L, _ = build_and_save_L_dlsfh()

    print_spectrum_report(L, name="L_dlsfh", k=5)

    # Compute pseudoinverse
    L_pinv = compute_L_pinv(L)
    path_L_pinv = save_matrix(L_pinv, "L_pinv.npy")
    print(f"L_pinv computed and saved to {path_L_pinv}")

    # Effective resistance (optional)
    R = None
    if save_resistance:
        R = effective_resistance_matrix(L_pinv)
        path_R = save_matrix(R, "R_eff.npy")
        print(f"Effective-resistance matrix R_ij saved to {path_R}")

        # Basic sanity checks
        n = R.shape[0]
        diag_zero = np.allclose(np.diag(R), 0.0, atol=1e-12)
        print(f"R_ij sanity check: n={n}, diag≈0? {diag_zero}")

    return L_pinv, R


# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    main_compute(save_resistance=True)
